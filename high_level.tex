We now describe, from a high level, the structure of the code, and where time is spent.

The driver code is in \file{nrniv/main1.cpp}. From the breakdown of the wall time for the TEST2 data set in \tbl{tbl:wallmain} it is apparent that from a computational point of view, the only component of importance is the time stepping/sover portion of the program in \lst{BBS_netpar_solve()}, which takes 99.8\% of time to solution.

Nevertheless, I will breifly describe the other steps performed in the main driver:
\begin{enumerate}
\item \lst{mk_mech()}\\
   The mechanisms are configured. A text file with a tuple for each mechanism (name, unique index, parameter count, type,  etc \dots) is scanned. This text file is (probably) generated when the \hoc files are generated, to provide a bridge between the runtime and the mechanisms implemented using the Neuron \hoc language.
\item \lst{mk_netcvode()}\\
    Creates a new \lst{NetCvode} object (see \file{nrnoc/netcvod.h/cpp}). I don't know the purpose of this (maybe responsible for managing thread-local data and communication between threads).
\item \lst{nrn_setup()}\\
    Before calling \lst{nrn_setup()}, the configuration file \file{files.dat} is read to see how many and which cells are to be loaded for simulation. The cells are assigned in a round-robin fashion between the MPI ranks. Then \lst{nrn_setup()} is called with a list of cell ids, to load the cell data from disk.
\item \lst{BBS_netpar_mindelay()} and \lst{mk_spikevec_buffer()}\\
    The mindelay and spike buffer size are configured. This is to do with spike communication (not yet understood).
\item \lst{BBS_netpar_solve()} \\
    The time stepping code. The focus of this report.
\item \lst{output_spikes()} \\
    Write spike information to disk.
\end{enumerate}

%-------------------------------------------------------------------------------
\begin{table}[htp!]
    \centering
%-------------------------------------------------------------------------------
\begin{tabular}{lrr}
\hline
section                    &    wall time (s) & contribution \% \\
\hline
\lst{mk_mech()}            &    0.01   &    0.0\\
\lst{mk_netcvode()}        &    0.00   &    0.0\\
\lst{nrn_setup()}          &    0.69   &    0.2\\
mindelay/spike buffer      &    0.15   &    0.0\\
\lst{BBS_netpar_solve()}   &    388.93 &   99.8\\
\lst{output_spikes()}      &    0.01   &    0.0\\
\hline
\end{tabular}
%-------------------------------------------------------------------------------
\label{tbl:wallmain}
\caption{Breakdown of wall time for TEST2 data set running on one node of Piz Daint, with 1 cell per core.}
\end{table}
%-------------------------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Drilling Down to The Time Step}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The time stepping and all computation associated with it are performed in the \lst{BBS_netpar_solve()} routine. A backtrace of the call tree from \lst{BBS_netpar_solve()} to \lst{nrn_fixed_step_thread()}, where 100\% of the computation is performed, is shown in \fig{fig:bbsnetpar}. The \lst{nrn_fixed_step_group*} loop over time steps and threads, while the.

\begin{figure}[htp!]
\centering
\includegraphics[width=\textwidth]{./images/bbs_netpar_solve.pdf}
\caption{backtrace to the main computational routine.}
\label{fig:bbsnetpar}
\end{figure}

Each MPI rank has a set of cells assigned to it in a round robin fashion during the initialization phase (in the call to \lst{nrn_setup()} in \lst{main()}). The cells are then assigned to a \lst{NrnThread} on each MPI rank. An abreviated definition of is given in \fig{lst:NrnThread}

\begin{figure}
\begin{shaded}
\begin{lstlisting}
struct NrnThread {
  // list of mechanisms
  NrnThreadMembList *tml;

  int ncell;        // number of cells
  int end;          // number of segments
  double *_data;    // data for all segment values
  ...               // other data fields

  // arrays holding matrix system values
  double *_actual_rhs;
  double *_actual_d;
  double *_actual_a;
  ...
  // area of each segment
  double *_actual_area;
  // parent index of segments
  int *_v_parent_index;
};
\end{lstlisting}
\end{shaded}
\label{lst:NrnThread}
\caption{The definition of the \lst{NrnThread} data type from \file{nrnoc/multicore.h}. Note that many data members have been removed, with just some fields of interest included.}
\end{figure}

